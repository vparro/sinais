%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 0 - Boas práticasclear all;clc;close all;pkg load control;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 1 - Domínio continuofosc  = 2*60;                % frequência de oscilaçãowosc  = 2*pi*fosc;           % frequência angularTosc  = 1/fosc;            % períoddo de oscilaçãoN     =  (wosc);                 % ganho ajustável D     =  [1 0 (wosc)^2];    % dinâmica - denominador%%% Funçào de transferência da série temporalGst = tf(N,D);##Transfer function 'Gst' from input 'u1' to output ...####             1## y1:  ---------------##      s^2 + 1.421e+05####Continuous-time model.%%% Visualizaçãofigure(1)impulse(Gst,2*Tosc)set(findall(gcf,'Type','line'),'LineWidth',3);set(gca,'FontSize',14,'LineWidth',2);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 1 - Domínio discreto - mapeamento%%% determinar os polos em tempo continuopolosL = roots(D);%%% mapeamento - Z = e^(sT)Fs   = 6000;          % amostragem temporal do sinal - 10 amostra / periodoT    = 1/Fs;         % período de amostragempolosZ = exp(polosL*T);%%% determinar o denominador em Z%%% (z - p1)*(z - p2) --> convDz   = conv([1 polosZ(1)],[1 polosZ(2)]);Nz   = 1%%% determinar a função GzGz   = tf(Nz,Dz,T);##Transfer function 'Gz' from input 'u1' to output ...####              1## y1:  -----------------##      z^2 + 0.618 z + 1####Sampling time: 0.00166667 s##Discrete-time model.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 2 - Gerar o algoritmo%%% (z^2 + 0.618 z + 1) * Y(z) = X(z)*Kz --> dinâmica%%%%%% y[k] = kz*x[k-2] + 0.618 y[k-1] - y[k-2]%%% Valores iniciaisya  = 0;        % atrasado de uma amostray2a = 0;        % atrasado de duas amostrasxa  = 0; x2a = 0; %%% Criar a entrada - x[k] - impulsoNx  = 2* Fs/fosc;                 % número de pontosx   = [1  zeros(1,Nx)];        % entrada%%% determino a saída  y[k] = kz*x[k-2] + 0.618 y[k-1] - y[k-2]kz    = 1;                % lavor que ajusta a amplitude for k = 1 : Nx - 3     y(k) = kz*x2a +Dz(2)*ya -y2a;      %%% atualização      y2a = ya;       ya  = y(k);      x2a = xa;   xa  = x(k);   end%%% Visualizaçãofigure(2)stem(y)set(findall(gcf,'Type','line'),'LineWidth',3);set(gca,'FontSize',14,'LineWidth',2);figure(3)subplot(2,1,1)impulse(Gst,2*Tosc)set(findall(gcf,'Type','line'),'LineWidth',3);set(gca,'FontSize',14,'LineWidth',2);subplot(2,1,2)stem(y)set(findall(gcf,'Type','line'),'LineWidth',3);set(gca,'FontSize',14,'LineWidth',2); 