%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 0 - Projeto de filtro e sintese de voz%% %% a. projetar um filtro digital de fc = 1000Hz e aplicar ao sinal gaita.wav%%%%%%  04 de junho de 2021%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 1 - Preparação do código %% %% Boas práticas: limpeza de variáveis; variáveis globais%% Constantes; carregar bibliotecas;...%%%%% Limpezaclc;          % limpa visual da tela de comandosclose all;    % limpa as figurasclear all;    % limpa as variáveis%%% Pacote de controlepkg load control         %%% Polos e zeros pkg load signal          %%% --> Bilinear%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 2 - Sinal: calibração e sinal real%%%% trabalhar com um sinal amostrado%% %% trabalhar com um sinal real - gaita - hamônica (série temporal, qualquer) [xk,fs] = audioread ('gaita.wav');      % transformei um arquivo .wav em um vetor x[k]  %%% do arquivo temos fs =  44100Hz - CD - (áudio 20kHz - fs_min = 40kHz)  T   = 1/fs;    %%% taxa de amostragem %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 3 - Fourier do sinal%%%% trabalhar com um sinal amostrado%% %%% Fourier do sinalXkF   =  fft(xk);%%% normalizandoXkF   =  XkF/max(abs(XkF));%%% Eixo frequência - calibraçãoNp    =  length(xk);          freq  =  linspace(-fs/2, fs/2, Np);%%% Visualizaçãofigure(1)plot(freq, abs(fftshift(XkF)));xlabel('Frequencia em Hz')ylabel('Magnitude')axis ([-5000 +5000])%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 4 - Projeto e uso do filtro%%%%  1. Equação diferencial%%  2. Laplace%%  3. Bilinear - Z%%  4. Equação de diferenças%%  5. Aplicação recursiva%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Especificar o filtrofc      = 2000;      % frequência de cortewc      = 2*pi*fc;   % frequência angularRC      = 1/wc;      % teoria de circuitos - constante de tempo RC%%%  2. LaplaceN   = 1;          % Numerador de LaplaceD   = [RC 1];     % Denominador de LaplaceHa  = tf(N,D);     % Função de transferência ## Transfer function 'Ha' from input 'u1' to output ...####             1## y1:  ---------------##      0.0001592 s + 1#### Continuous-time model.%%% 3. Bilinear - Z%% s = 2/T * (z-1)/(Z+1)%%% Filtro% y(k) = 1/a*x(k) + 1/a x(k-1) - b/a y(k-1)%%% Da aula de teoriaa = 2*RC/T + 1;b = 1 - 2*RC/T;%%% Implementar o filtroNp   = length(xk);%%% Valores iniciaisxa  = 0;ya  = 0;for k = 1 : Np    %%% equação de diferenças do filtro    y(k) = (1/a)*xk(k) + (1/a)*xa - (b/a)*ya;    %%% atualizo as variáveis    xa = xk(k);  ya = y(k);  end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 5 - Verificação%%%%  Analisar se o filtro faz o que queremos!!!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fourier da entradaXkF   =  fft(xk);%%% normalizandoXkF   =  XkF/max(abs(XkF));%%% Eixo frequência - calibraçãoNp    =  length(xk);          freq  =  linspace(-fs/2, fs/2, Np);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fourier da saidaYF   =  fft(y);%%% normalizandoYF   =  YF/max(abs(YF));%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Visualizandofigure(2)subplot(2,1,1); plot(xk);subplot(2,1,2); plot(y);figure(3)subplot(2,1,1); plot(freq, abs(fftshift(XkF)));xlabel('Frequencia em Hz')ylabel('Magnitude')axis ([-5000 +5000])set(findall(gcf,'Type','line'),'LineWidth',3);set(gca,'FontSize',14,'LineWidth',2);subplot(2,1,2); plot(y);plot(freq, abs(fftshift(YF)));xlabel('Frequencia em Hz')ylabel('Magnitude')axis ([-5000 +5000])set(findall(gcf,'Type','line'),'LineWidth',3);set(gca,'FontSize',14,'LineWidth',2);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Resposta do filtro%%% entradaXkF   =  fft(xk);%%% saidaYF   =  fft(y);%%% Sistema - ganho ou função de transferência (em valores)Hf   = YF./XkF';figure(4)plot(freq, abs(fftshift(Hf)));xlabel('Frequencia em Hz')ylabel('Magnitude')title('Resposta do filtro')axis ([-5000 +5000])set(findall(gcf,'Type','line'),'LineWidth',3);set(gca,'FontSize',14,'LineWidth',2);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 5 - Automação de processos%%%%  uso de comandos dedicados%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 3. Bilinear - Z##          +---------------+-----------------------+----------------------+##          | Transform     | Zero at x             | Pole at x            |##          |    H(S)       |   H(S) = S-x          |    H(S)=1/(S-x)      |##          +---------------+-----------------------+----------------------+##          |       2 z-1   | zero: (2+xT)/(2-xT)   | zero: -1             |##          |  S -> - ---   | pole: -1              | pole: (2+xT)/(2-xT)  |##          |       T z+1   | gain: (2-xT)/T        | gain: (2-xT)/T       |##          +---------------+-----------------------+----------------------+%%% Sintaxe de comando[Nd,Dd]   = bilinear(N,D,T);Hd        = tf(Nd,Dd,T);## Transfer function 'Hd' from input 'u1' to output ...####      0.1247 z + 0.1247## y1:  -----------------##         z - 0.7506#### Sampling time: 2.26757e-05 s## Discrete-time model.%%% Implementar o filtro - yf : saída do filtro####     'filter' returns the solution to the following linear,##     time-invariant difference equation:####           N                   M##          SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)    for 1<=n<=length(x)##          k=0                 k=0####     where N=length(a)-1 and M=length(b)-1.  The result is calculated##     over the first non-singleton dimension of X or over DIM if##     supplied.yf    = filter(Nd,Dd,xk); 