%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 1 - Preparação do código %% %% Boas práticas: limpeza de variáveis; variáveis globais%% Constantes; carregar bibliotecas;...%%%%% Limpezadisplay('1 - Preparando o código ...')clc;          % limpa visual da tela de comandosclose all;    % limpa as figurasclear all;    % limpa as variáveis%%% Carregar bibliotecaspkg load symbolic;  % biblioteca simbólica%%% Omite mensagens de warningswarning('off');     % não mostra eventos de warning%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 2 - Problema%%%% aproximar uma exponencial por uma série exponencial de Fourier%% %% Definir a função g(t) = exp(-t)display('2 - Definindo o sinal g(t) ...')%%% do problema a ser analisadoTo = 1;     % período da onda quadradato = 0;     % instante inicial de g(t)%%% Parâmetros calculadosfo = 1/To;    % frequência da onda quadradawo = 2*pi*fo; % frequência angular de g(t)%%% função g(t) teóricagtTeo = @(t) exp(-t);   % função g(t) - handle%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  3 - calcular o valor de Dn - Fourier%% %%  Ambiente de cálculo integral e simbólico%%  %%  Symbolic pkg v2.9.0: %%  Python communication link active, SymPy v1.5.1.%%%%%%  Dn = 1/To int_0^To g(t) exp(-j n wo t) dt%%%%  g(t) = exp(-t)  - função a ser decomposta%%display('3 - Série de Fourier simbólica ...')syms n t  % t - tempo variável simbólica%%% numerador de Dn - integral de FourierInum    = int(exp(-(1+j*wo*n)*t),t,to,To+to);%%% DnDn = Inum/To;     % análise teórica%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 4 -  Analisando as projeçõesn     = [-1 0 +1];        % valores de n para análise da primeira harmônicaDnNum =  eval(Dn);      % substitui os valores de 'n' em 'Dn'%%% sintetizando a primeira harmônica - p1(t)M     = 1000;                       % resolução do sinaltempo = linspace(-To,To,M);         % intervalo de análise com M pontosp1    =  DnNum(1)*exp(j*n(1)*wo*tempo) + DnNum(2) + DnNum(3)*exp(j*n(3)*wo*tempo);%%% comparar a primiera harmônica com o sinal teóricotempo1 = linspace(0,To,M/2);             % vetor de tempo para o sinal teóricogtNum  = [gtTeo(tempo1) gtTeo(tempo1)];  % o valor numérico teórico%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  5 - Visualizando a aproximaçãofigure(1)plot(tempo,gtNum,'b..','linewidth',3);  % sinal teóricohold;plot(tempo, p1,'k-','linewidth',3);     % sinal aproximadoxlabel('Tempo em segundos');            %ylabel('Amplitude');                    %title('Função aproximada - comparacao') %grid%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 6 -  Analisando as projeçõesn     = [-2 +2];        % valores de n para análise da primeira harmônicaDnNum =  eval(Dn);      % substitui os valores de 'n' em 'Dn'%%% sintetizando a primeira harmônica - p1(t)M     = 1000;                       % resolução do sinaltempo = linspace(-To,To,M);         % intervalo de análise com M pontosp2    =  p1 + DnNum(1)*exp(j*n(1)*wo*tempo) + DnNum(2)*exp(j*n(2)*wo*tempo);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  7 - Visualizando a aproximaçãofigure(2)plot(tempo,gtNum,'b..','linewidth',3);  % sinal teóricohold;plot(tempo, p2,'k-','linewidth',3);     % sinal aproximadoxlabel('Tempo em segundos');            %ylabel('Amplitude');                    %title('Função aproximada - comparacao') %grid