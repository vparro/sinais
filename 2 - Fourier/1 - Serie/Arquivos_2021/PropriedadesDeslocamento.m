%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 1 - Preparação do código %% %% Boas práticas: limpeza de variáveis; variáveis globais%% Constantes; carregar bibliotecas;...%%%%% Limpezaclc;          % limpa visual da tela de comandosclose all;    % limpa as figurasclear all;    % limpa as variáveiswarning('off', 'all'); % omite os warnings%%% Carregar bibliotecaspkg load symbolic;  % biblioteca simbólica%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 2 - Problema no tempo%%%% aproximar uma onda quadrada por um sinal%% harmônico - g(t) = série exponencial%% %% Definir a onda pulsada positivaAp = +1;    % amplitude positiva de g(t)An = 0;     % amplitude negativa de g(t)To = 1;     % período da onda quadradato = -0.25; % instante inicial de g(t)%%% Parâmetros calculadosfo = 1/To;    % frequência da onda quadradawo = 2*pi*fo; % frequência angular de g(t)%%% Para a onda deslocadadelta = 0.25  % deslocamento da onda%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  3 - calcular o valor de Dn%% %%  Ambiente de cálculo integral e simbólico%%  %%  Symbolic pkg v2.9.0: %%  Python communication link active, SymPy v1.5.1.%%syms n t  % t - tempo variável simbólica%%% Numerador de DnIp    = int(Ap*exp(-j*n*wo*t),t,to,to+To/2);In    = int(An*exp(-j*n*wo*t),t,to+To/2,to+To);Inum  = Ip + In; %%% Determinando DnDn = Inum/To;%%% Determinar o valor médioIp    = int(Ap*exp(-j*0*wo*t),t,to,to+To/2);In    = int(An*exp(-j*0*wo*t),t,to+To/2,to+To);Inum  = Ip + In; %%% Determinando D0D0 = Inum/To;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 4 -  Valores no domínio da frequênciaN    = 10;          % Número de harmônicasn    = [-N:1:N];    % Harmônicas de Fourierfreq = n*fo;        % frequências de FourierD0     = eval(D0);    % transforma em númeroDn     = eval(Dn);    % substitui os valores de n na variável Dn Dn(N+1) = D0          % atualizei o valor médio do sinal%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Sintetizar o sinal - retorno ao domínio do tempo%%%%%%%%  g(t)  = sum_{n=-N}^{n=N} Dn exp(j n wo t)%%gt    =  0;                   % inicia com um valor nulogt1   =  0;                   % sinal deslocadoM     =  1000;                % resolução do meu sinaltempo = linspace(-To,To,M);   % variável tempo for k = 1 : 2*N+1             % N valores negativos                              % N valores positivos                              % e o zero --> 2*N+1                                  gt =  gt + Dn(k)*exp(j*n(k)*wo*tempo);  % sinal original    gt1 =  gt1 + (exp(-j*n(k)*pi/2)*Dn(k))*exp(j*n(k)*wo*tempo);  % sinal deslocado    end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  %%%%%%   Visualizar o sinal no domínio do tempo e da frequência%%  %%figure(1)stem(freq,Dn,'k-','linewidth',3);xlabel('Frequência angular');ylabel('Amplitude');title('Fourier exponencial')gridfigure(2)plot(tempo,gt,'g-','linewidth',3);hold;                                 % retem o primeiro gráfico - memóriaplot(tempo,gt1,'k-','linewidth',3);xlabel('tempo em segundos');ylabel('Amplitude');title('Fourier exponencial')grid