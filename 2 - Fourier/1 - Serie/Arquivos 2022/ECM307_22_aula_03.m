%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 1 - Preparação do código %% %% Boas práticas: limpeza de variáveis; variáveis globais%% Constantes; carregar bibliotecas;...%%%%% Limpezaclc;          % limpa visual da tela de comandosclose all;    % limpa as figurasclear all;    % limpa as variáveis%%% Carregar bibliotecaspkg load symbolic;  % biblioteca simbólica - somente no Octave%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 2 - Problema%%%% aproximar uma onda quadrada por um sinal%% harmônico - g(t) = c. sin(t) + erro%% %% Definir a onda quadradaAp = +1;    % amplitude positiva de g(t)An = -1;    % amplitude negativa de g(t)To = 2*pi;  % período da onda quadradato = 0;     % instante inicial de g(t)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 3 - Determinar o coeficiente cn%%syms Ap An To to n t%%% NumeradorNum = int(Ap*sin(n*t),t,to,to+To/2) + int(An*sin(n*t),t,to+To/2,to+To);%%% DenominadorDen = int(sin(n*t)*sin(n*t),t,to,to+To);%%% Determinando o coeficiente cncn  = Num/Den;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 4 - Calculando cn numericamente e visualizando%%n = [1 2 3];      % senoide de mesma frequência da onda quadradaAp = +1;          % amplitude positiva de g(t)An = -1;          % amplitude negativa de g(t)To = 2*pi;        % período da onda quadradato = 0;           % instante inicial de g(t)c  = eval(cn);%%% Criando o vetor tempotempo = linspace(to,To,1000);g1    = c(1)*sin(tempo)+c(2)*sin(2*tempo)+c(3)*sin(3*tempo);% automatizar via SW% g1    = 1.27324*sin(tempo)+0.00000*sin(2*tempo)+0.42441*sin(3*tempo);% Conclusão: a onda quadrada é ortogonal a sin(2t)% o coeficiente cn indica a "projeção" do sinal g(t) no sinal x(t)% Se a projeção é nula indica que os sinais são ortogonais%%% Criando a onda quadradagt    = [ones(1,500) -ones(1,500)];%%% Visualizando os dois sinaisfigure(1)plot(tempo,g1,'bo');    % sinal aproximadohold;                   % fixa o primeiro gráficoplot(tempo,gt,'k+');    % sinal da onda quadradagrid;figure(2)plot(tempo,gt-g1,'bo');    % obervando o errogrid;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 5 - Calculando as projeções pelo erro - automatizar%%syms Ap An To to t%%% NumeradorNum = int((Ap-1.27324*sin(t))*sin(3*t),t,to,to+To/2) + int((An-1.27324*sin(t))*sin(3*t),t,to+To/2,to+To);%%% DenominadorDen = int(sin(3*t)*sin(3*t),t,to,to+To);%%% Determinando o coeficiente cnc3  = Num/Den;%%% Determinando numericamenten = 3;            % senoide de mesma frequência da onda quadradaAp = +1;          % amplitude positiva de g(t)An = -1;          % amplitude negativa de g(t)To = 2*pi;        % período da onda quadradato = 0;           % instante inicial de g(t)c3  = eval(c3);